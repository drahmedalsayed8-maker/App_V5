<!DOCTYPE html>
<html lang="en">
<head>
<script>
(function(){
  try{
    var qs = new URLSearchParams(location.search);
    var from = qs.get('from') || '';
    var slot = qs.get('slot') || '';
    if (from === 'photo' || slot){
      document.documentElement.classList.add('from-photo');
      document.addEventListener('DOMContentLoaded', function(){
        var ov = document.getElementById('auto-load-overlay');
        if (ov) ov.style.display = 'flex';
      });
    }
  }catch(e){}
})();
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0b1220">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icons/icon-192.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <title>Occlusal Analysis Pro - Cant & Midline Measurement</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .app-container {
            display: flex;
            min-height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 320px;
            background: linear-gradient(180deg, #2c3e50 0%, #1a2530 100%);
            color: white;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
            box-shadow: 5px 0 20px rgba(0, 0, 0, 0.2);
        }
        
        .sidebar-header {
            padding: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .sidebar-header h2 {
            margin: 0;
            font-size: 22px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sidebar-header h2 i {
            color: #3498db;
        }
        
        .sidebar-subtitle {
            color: #bdc3c7;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .points-section {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #ecf0f1;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .points-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        
/* Points list as a scroll wheel */
.points-wheel{
    width: 100%;
    min-height: 320px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ecf0f1;
    border-radius: 14px;
    padding: 10px;
    outline: none;
}
.points-wheel:focus{
    box-shadow: 0 0 0 3px rgba(52,152,219,0.35);
}
.points-wheel option{
    padding: 10px 8px;
    background: rgba(26,37,48,0.98);
    color: #ecf0f1;
}
.point-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .point-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }
        
        .point-card.active {
            background: rgba(52, 152, 219, 0.2);
            border-color: #3498db;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.2);
        }
        
        .point-card.placed {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
        }
        
        .point-number {
            width: 32px;
            height: 32px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .point-card.active .point-number {
            background: #fff;
            color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }
        
        .point-card.placed .point-number {
            background: #2ecc71;
        }
        
        .point-info {
            flex: 1;
        }
        
        .point-name {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
        }
        
        .point-desc {
            font-size: 12px;
            color: #bdc3c7;
            line-height: 1.4;
        }
        
        .point-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            flex-shrink: 0;
        }
        
        .point-card.placed .point-status {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .sidebar-controls {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.3);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-reference {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            margin-top: 10px;
        }
        
        .btn-reference:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(155, 89, 182, 0.3);
        }
        
        /* Main Content Styles */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .main-header {
            padding: 25px 30px;
            background: white;
            border-bottom: 1px solid #eaeaea;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .main-header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .main-header-subtitle {
            color: #7f8c8d;
            margin-top: 8px;
            font-size: 16px;
        }
        
        .analysis-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .image-section {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            position: relative;
        }
        
        /* Enhanced Upload Area */
        .upload-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            text-align: center;
            text-shadow: 0 2px 6px rgba(0,0,0,0.65);
            z-index: 10;
            display: none;
        }
        
        .upload-area.active {
            display: block;
            animation: fadeInUp 0.6s ease;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .upload-card {
            background: white;
            border-radius: 20px;
            padding: 50px 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            border: 2px dashed #e0e0e0;
            transition: all 0.3s ease;
        }
        
        .upload-card:hover {
            border-color: #3498db;
            box-shadow: 0 25px 70px rgba(52, 152, 219, 0.2);
        }
        
        .upload-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 30px;
            color: white;
            font-size: 40px;
            box-shadow: 0 10px 30px rgba(52, 152, 219, 0.3);
        }
        
        .upload-title {
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .upload-subtitle {
            color: #7f8c8d;
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 10px 30px rgba(46, 204, 113, 0.3);
        }
        
        .upload-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(46, 204, 113, 0.4);
        }
        
        .upload-note {
            margin-top: 25px;
            color: #95a5a6;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
                .canvas-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);

            /* Size tuning: keep the image area compact (better on desktop & mobile/PWA) */
            flex: 0 0 auto;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            min-height: 260px;
            max-height: 520px;
            padding: 12px;

            display: flex;
            align-items: center;
            justify-content: center;

            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .canvas-container.active {
            opacity: 1;
        }

        #face-canvas {
            max-width: 100%;
            max-height: 496px;
            width: auto;
            height: auto;
            display: block;
        }

.image-controls {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .image-controls.active {
            opacity: 1;
        }
        
        .btn-upload {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }
        
        .btn-reset {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }
        
        .btn-upload:hover, .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .analysis-section {
            width: 500px;
            padding: 30px;
            overflow-y: auto;
            background: white;
            border-left: 1px solid #eaeaea;
        }
        
        .analysis-tabs {
            display: flex;
            border-bottom: 2px solid #f0f0f0;
            margin-bottom: 25px;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .metric-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateX(5px);
        }
        
        .metric-card.good {
            border-left-color: #2ecc71;
        }
        
        .metric-card.warning {
            border-left-color: #f39c12;
        }
        
        .metric-card.alert {
            border-left-color: #e74c3c;
        }
        
        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .metric-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .metric-value {
            font-weight: 700;
            font-size: 18px;
            font-family: 'Courier New', monospace;
        }
        
        .metric-value.good {
            color: #2ecc71;
        }
        
        .metric-value.warning {
            color: #f39c12;
        }
        
        .metric-value.alert {
            color: #e74c3c;
        }
        
        .metric-description {
            color: #7f8c8d;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .progress-container {
            margin-top: 10px;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #7f8c8d;
        }
        
        .progress-bar {
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #3498db);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            overflow: auto;
        }
        
        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.4s ease;
        }
        
        @keyframes modalSlideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        
        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
        }
        
        .close-modal {
            font-size: 28px;
            font-weight: bold;
            color: #95a5a6;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .close-modal:hover {
            color: #e74c3c;
        }
        
        .reference-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .reference-image-container {
            text-align: center;
        }
        
        .reference-image {
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .reference-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }
        
        .reference-list ol {
            padding-left: 20px;
        }
        
        .reference-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: white;
            border-top: 1px solid #eaeaea;
            font-size: 14px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #e74c3c;
        }
        
        .status-dot.active {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .points-progress {
            width: 200px;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .points-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        /* Results Table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }
        
        .results-table th {
            background: #2c3e50;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .results-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #eaeaea;
        }
        
        .results-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .results-table .ideal {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .results-table .actual {
            color: #3498db;
            font-weight: bold;
        }
        
        .results-table .deviation {
            color: #e74c3c;
            font-weight: bold;
        }
        
        /* Calibration Modal */
        .calibration-options {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        
        .calibration-option {
            flex: 1;
            text-align: center;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .calibration-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .calibration-option.selected {
            border-color: #3498db;
            background: #e8f4fc;
        }
        
        .calibration-icon {
            font-size: 40px;
            color: #3498db;
            margin-bottom: 15px;
        }
        
        
        .calibration-icon svg{ width:44px; height:44px; display:inline-block; }
.calibration-input {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }
        
        .calibration-input.active {
            display: block;
        }
        
        .calibration-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .calibration-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        /* Export Button */
        .btn-export {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            margin-top: 15px;
        }
        
        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(243, 156, 18, 0.3);
        }
        
        /* Enhanced Measurement Labels */
        .measurement-label {
            position: absolute;
            background: rgba(15, 23, 42, 0.0);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.0);
            box-shadow: none;
            backdrop-filter: none;
            min-width: 120px;
            text-align: center;
            text-shadow: 0 2px 6px rgba(0,0,0,0.65);
        }
        
        .measurement-label .value {
            font-size: 14px;
            font-weight: 700;
            color: #3498db;
            margin-left: 4px;
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .analysis-container {
                flex-direction: column;
            }
            
            .analysis-section {
                width: 100%;
                height: 400px;
            }
            
            .sidebar {
                width: 280px;
            }
        }
        
        @media (max-width: 900px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
            }
            
            .points-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .upload-area {
                width: 95%;
            }
            
            .upload-card {
                padding: 30px 20px;
            }
            
            .calibration-options {
                flex-direction: column;
            }
        }
        
        @media (max-width: 600px) {
            .points-grid {
                grid-template-columns: 1fr;
            }
            
            .reference-grid {
                grid-template-columns: 1fr;
            }
            
            .upload-title {
                font-size: 24px;
            }
            
            .upload-btn {
                padding: 15px 30px;
                font-size: 16px;
            }
        }
    
        .image-section{ position: relative; }

        /* Auto-load overlay (when arriving from photo.html) */
        html.from-photo #upload-area{ display:none !important; }
        .image-section{ position: relative; }
        .auto-load-overlay{
            position:absolute;
            inset:0;
            display:flex;
            align-items:center;
            justify-content:center;
            z-index:50;
            background:rgba(0,0,0,0.35);
            backdrop-filter: blur(2px);
        }
        .auto-load-card{
            background:rgba(15,23,42,0.92);
            border:1px solid rgba(255,255,255,0.10);
            border-radius:18px;
            padding:22px 26px;
            text-align:center;
            color:#fff;
            min-width:240px;
            box-shadow:0 18px 50px rgba(0,0,0,0.35);
        }
        .spinner{
            width:34px; height:34px;
            border-radius:50%;
            border:4px solid rgba(255,255,255,0.25);
            border-top-color: rgba(255,255,255,0.95);
            margin:0 auto;
            animation:spin 0.85s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Undo button under points list */
        .undo-wrap{
            display:flex;
            justify-content:center;
            margin-top: 14px;
        }
        #undo-point-btn{
            width: 100%;
            max-width: 260px;
        }
        #undo-point-btn:disabled{
            opacity: 0.55;
            cursor: not-allowed;
        }



/* === Modern Sidebar Skin (RRZ) - START === */
:root{
  --rrz-sb-bg1:#0b1220;
  --rrz-sb-bg2:#0f1a2a;
  --rrz-sb-card:rgba(255,255,255,0.06);
  --rrz-sb-card2:rgba(255,255,255,0.08);
  --rrz-sb-border:rgba(255,255,255,0.10);
  --rrz-sb-border2:rgba(255,255,255,0.14);
  --rrz-sb-text:rgba(255,255,255,0.92);
  --rrz-sb-muted:rgba(255,255,255,0.62);
  --rrz-sb-accent:#6ea8ff;
  --rrz-sb-accent2:#2ecc71;
}

.sidebar{
  width: 292px;
  background: radial-gradient(1200px 500px at 20% 0%, rgba(110,168,255,0.18), transparent 55%),
              linear-gradient(180deg, var(--rrz-sb-bg1) 0%, var(--rrz-sb-bg2) 100%);
  color: var(--rrz-sb-text);
  box-shadow: 8px 0 24px rgba(0,0,0,0.18);
  border-right: 1px solid rgba(255,255,255,0.06);
}

.sidebar-header{
  padding: 18px 18px 14px;
  background: rgba(255,255,255,0.03);
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.sidebar-header h2{
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 0.2px;
  margin: 0;
  color: var(--rrz-sb-text);
}

.sidebar-header h2 i{
  color: var(--rrz-sb-accent);
  filter: drop-shadow(0 6px 10px rgba(110,168,255,0.22));
}

.sidebar-subtitle{
  margin-top: 6px;
  font-size: 12px;
  color: var(--rrz-sb-muted);
  line-height: 1.35;
}

.points-section{
  padding: 14px 14px 10px;
}

.section-title{
  font-size: 13px;
  font-weight: 700;
  color: rgba(255,255,255,0.86);
  margin-bottom: 10px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

#points-count{
  font-variant-numeric: tabular-nums;
  opacity: 0.85;
}

.points-wheel{
  background: linear-gradient(180deg, var(--rrz-sb-card2), var(--rrz-sb-card));
  border: 1px solid var(--rrz-sb-border);
  border-radius: 16px;
  padding: 10px 10px;
  min-height: 340px;
  color: rgba(255,255,255,0.92);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
}

.points-wheel:focus{
  outline: none;
  box-shadow: 0 0 0 3px rgba(110,168,255,0.28), inset 0 0 0 1px rgba(255,255,255,0.03);
}

.points-wheel option{
  padding: 10px 10px;
  margin: 2px 0;
  border-radius: 10px;
  background: rgba(8, 13, 23, 0.98);
  color: rgba(255,255,255,0.92);
}

.points-wheel option:checked{
  background: rgba(110,168,255,0.22);
}

.points-wheel::-webkit-scrollbar{
  width: 10px;
}
.points-wheel::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,0.14);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,0.35);
}
.points-wheel::-webkit-scrollbar-track{
  background: rgba(0,0,0,0.12);
  border-radius: 999px;
}

.sidebar-controls{
  padding: 12px 14px 16px;
  border-top: 1px solid rgba(255,255,255,0.08);
  background: rgba(0,0,0,0.10);
  gap: 10px;
}

.btn{
  border-radius: 14px;
  padding: 12px 12px;
  font-size: 14px;
  letter-spacing: 0.1px;
}

.btn:focus-visible{
  outline: none;
  box-shadow: 0 0 0 3px rgba(110,168,255,0.26);
}

.btn-secondary{
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.14);
}

.btn-secondary:hover{
  background: rgba(255,255,255,0.10);
  border-color: rgba(255,255,255,0.18);
}

.btn-primary{
  background: linear-gradient(135deg, rgba(110,168,255,1) 0%, rgba(52,152,219,1) 55%, rgba(41,128,185,1) 100%);
  box-shadow: 0 14px 26px rgba(52,152,219,0.22);
}

.btn-primary:hover{
  transform: translateY(-1px);
  box-shadow: 0 18px 34px rgba(52,152,219,0.28);
}

.btn-reference{
  background: linear-gradient(135deg, rgba(170,120,255,1) 0%, rgba(142,68,173,1) 100%);
  box-shadow: 0 14px 26px rgba(142,68,173,0.20);
  margin-top: 2px;
}

.btn-reference:hover{
  transform: translateY(-1px);
  box-shadow: 0 18px 34px rgba(142,68,173,0.26);
}

.btn-export{
  background: linear-gradient(135deg, rgba(255,187,92,1) 0%, rgba(230,126,34,1) 100%);
  box-shadow: 0 14px 26px rgba(230,126,34,0.20);
  margin-top: 4px;
}

.btn-export:hover{
  transform: translateY(-1px);
  box-shadow: 0 18px 34px rgba(230,126,34,0.26);
}

@media (max-width: 1200px){
  .sidebar{ width: 270px; }
}
@media (max-width: 900px){
  .sidebar{
    width: 100%;
    box-shadow: none;
    border-right: none;
    border-bottom: 1px solid rgba(0,0,0,0.08);
  }
  .points-wheel{ min-height: 240px; }
}
/* === Modern Sidebar Skin (RRZ) - END === */



/* Unified Calibration Modal Theme */
#calibration-modal.modal, #calib-settings-modal.modal{
  display:none;
  position:fixed;
  z-index:1000;
  left:0; top:0;
  width:100%; height:100%;
  background: rgba(0,0,0,0.80);
  backdrop-filter: blur(5px);
  overflow:auto;
}
#calibration-modal .calib-unified, #calib-settings-modal .calib-unified{
  background:#ffffff !important;
  margin:50px auto !important;
  padding:0 !important;
  border-radius:20px !important;
  width:90% !important;
  max-width:600px !important;
  box-shadow:0 20px 40px rgba(0,0,0,0.20) !important;
  overflow:hidden !important;
  position:relative !important;
}
.calib-unified .modal-header{
  background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d) !important;
  color:#ffffff !important;
  padding:20px 30px !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:16px !important;
}
.calib-unified .modal-header h2,
.calib-unified .modal-header h3{
  margin:0 !important;
  font-size:20px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.calib-unified .close-modal,
.calib-unified .close-calib{
  color:#ffffff !important;
  font-size:28px !important;
  font-weight:700 !important;
  cursor:pointer !important;
  background:transparent !important;
  border:0 !important;
  line-height:1 !important;
}
.calib-unified .modal-body{
  padding:25px 30px !important;
}
.calib-unified .modal-subtitle{
  margin:0 0 10px 0 !important;
  color:#475569 !important;
  font-size:13px !important;
}
.calib-unified .calibration-options,
.calib-unified .calib-grid{
  display:flex !important;
  gap:20px !important;
  margin:18px 0 0 0 !important;
  flex-wrap:wrap !important;
}
.calib-unified .calibration-option,
.calib-unified .calib-card{
  flex:1 1 240px !important;
  background:#f8f9fa !important;
  border-radius:15px !important;
  padding:20px !important;
  cursor:pointer !important;
  border:2px solid transparent !important;
  transition: all 0.25s ease !important;
  box-shadow:0 10px 20px rgba(0,0,0,0.06) !important;
}
.calib-unified .calibration-option:hover,
.calib-unified .calib-card:hover{
  transform: translateY(-3px) !important;
  box-shadow:0 15px 30px rgba(0,0,0,0.10) !important;
}
.calib-unified .calibration-option.selected,
.calib-unified .calib-card.selected{
  border-color:#b21f1f !important;
  background:#fff4f4 !important;
}
.calib-unified .calibration-icon,
.calib-unified .calib-icon{
  width:60px !important;
  height:60px !important;
  border-radius:50% !important;
  background: linear-gradient(135deg, #1a2a6c, #b21f1f) !important;
  color:#ffffff !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  margin:0 auto 15px auto !important;
  font-size:24px !important;
}
.calib-unified h3, .calib-unified .calib-card-title{
  margin:0 0 8px 0 !important;
  text-align:center !important;
  font-size:16px !important;
  color:#0f172a !important;
}
.calib-unified p, .calib-unified .calib-card-desc{
  margin:0 !important;
  text-align:center !important;
  color:#475569 !important;
  font-size:13px !important;
}
.calib-unified .calibration-input,
.calib-unified .calib-manual-input,
.calib-unified .calib-fields{
  margin-top:14px !important;
  background:#ffffff !important;
  border-radius:12px !important;
  padding:14px !important;
  border:1px solid #e2e8f0 !important;
}
.calib-unified label{
  display:block !important;
  font-size:13px !important;
  color:#334155 !important;
  margin-bottom:6px !important;
}
.calib-unified input[type="number"],
.calib-unified input[type="text"]{
  width:100% !important;
  padding:12px !important;
  border:2px solid #e2e8f0 !important;
  border-radius:10px !important;
  font-size:14px !important;
}
.calib-unified .calib-inline{
  display:flex !important;
  gap:10px !important;
  align-items:center !important;
}
.calib-unified .calib-help{
  margin-top:8px !important;
  font-size:12px !important;
  color:#64748b !important;
}
.calib-unified .modal-footer,
.calib-unified .modal-actions,
.calib-unified .calib-actions{
  display:flex !important;
  justify-content:flex-end !important;
  gap:12px !important;
  padding:0 30px 25px 30px !important;
}
.calib-unified .btn{
  border-radius:12px !important;
}
.calib-unified .calib-radio-row{
  display:flex !important;
  gap:8px !important;
  align-items:center !important;
  justify-content:center !important;
  margin-top:12px !important;
  font-size:13px !important;
  color:#334155 !important;
}




/* === RRZ_MOBILE_RESPONSIVE_V1.2 === */
:root{--vh:1vh;}

/* Ensure the app uses the full viewport on mobile/tablet */
@media (max-width: 1024px){
  body{ overflow:hidden; }
  .app-container{ max-width:none !important; margin:0 !important; width:100vw !important;
    height: calc(var(--vh, 1vh) * 100) !important;
    min-height: calc(var(--vh, 1vh) * 100) !important;
  }
  /* Sidebars shrink to avoid covering the image */
  .sidebar{ width: min(260px, 36vw) !important; flex-shrink:0 !important; }
  .main-content, .canvas-container{ min-width:0 !important; }
}

/* Portrait mode: show rotate overlay (we still allow "Continue" as fallback) */
body.rrz-portrait-lock .app-container{ display:none !important; }

#rrzRotateOverlay{ position: fixed; inset: 0; z-index: 9999; display:none;
  align-items:center; justify-content:center; padding: 18px;
  background: rgba(0,0,0,0.85);
}
#rrzRotateOverlay .box{ width:min(560px, 92vw); background:#0b1220; border:1px solid rgba(197,160,89,0.45);
  border-radius: 14px; padding: 16px; box-shadow: 0 12px 40px rgba(0,0,0,0.65);
}
#rrzRotateOverlay .title{ font-weight: 900; font-size: 16px; margin-bottom: 10px; color:#c5a059; }
#rrzRotateOverlay .hint{ color: rgba(255,255,255,0.82); font-size: 13px; line-height: 1.6; margin-bottom: 12px; }
#rrzRotateOverlay .row{ display:flex; gap:10px; flex-wrap:wrap; }
#rrzRotateOverlay .btn{ flex:1; min-width: 190px; padding: 10px 12px; border-radius: 10px; cursor:pointer;
  font-weight: 800; letter-spacing: 0.2px; border: 1px solid rgba(197,160,89,0.55);
  background: rgba(197,160,89,0.10); color: #c5a059;
}
#rrzRotateOverlay .btn.secondary{ border-color: rgba(255,255,255,0.22); background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.92); }


        /* RRZ_RESPONSIVE_LAYOUT_V1.0 */
        @media (max-width: 1100px){ .sidebar{ width: 280px; } }
        @media (max-width: 920px){ .sidebar{ width: 240px; } }
        @media (max-width: 760px){
          body{ overflow:auto; }
          .app-container{ flex-direction: column; height: 100vh; }
          .sidebar{ width: 100%; height: 42vh; border-right: none; border-bottom: 1px solid #374151; }
          .main-content{ height: 58vh; }
        }

        /* ===== Mobile rotate & landscape layout (PWA UX patch) ===== */
        .rotate-overlay{
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.88);
            color: #fff;
            z-index: 999999;
            padding: 24px;
            text-align: center;
        }
        .rotate-overlay .rotate-card{
            max-width: 420px;
            width: 100%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 18px;
            padding: 22px 18px;
            backdrop-filter: blur(8px);
        }
        .rotate-overlay .rotate-icon{
            font-size: 44px;
            margin-bottom: 10px;
        }
        .rotate-overlay h2{
            margin: 0 0 8px 0;
            font-size: 20px;
            line-height: 1.25;
        }
        .rotate-overlay p{
            margin: 0;
            opacity: 0.9;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Force rotate on phones when portrait */
        @media (max-width: 900px) and (orientation: portrait){
            .rotate-overlay{ display: flex; }
            body{ overflow: hidden; }
        }

        /* Improve landscape on mobile: keep sidebar next to content + allow scroll */
@media (max-width: 900px) and (orientation: landscape){
    html, body{
        height: auto !important;
        min-height: 100% !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
    }
    body{ -webkit-overflow-scrolling: touch; }

    .app-container{
        flex-direction: row !important;
        height: auto !important;
        min-height: 100vh !important;
        width: 100% !important;
        max-width: 100% !important;
        align-items: stretch !important;
    }

    .sidebar{
        width: 250px !important;
        position: sticky !important;
        top: 0;
        height: 100vh !important;
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch;
    }

    .main-content{
        height: auto !important;
        min-height: 100vh !important;
        overflow: visible !important;
    }

    /* Prevent clipping in nested containers */
    .analysis-container, .content, .main, .canvas-wrap, .viewer, .workspace{
        height: auto !important;
        overflow: visible !important;
        min-height: 0 !important;
    }

    /* Stack result/notes panels under the image on phones to avoid covering/cropping */
    .analysis-container{
        flex-direction: column !important;
        align-items: stretch !important;
    }

    .analysis-section, .results-panel, .right-panel, .analysis-panel{
        width: 100% !important;
        max-width: none !important;
        height: auto !important;
        max-height: none !important;
        overflow: visible !important;
        border-left: none !important;
        border-top: 1px solid rgba(0,0,0,0.08) !important;
    }

    .image-section{
        padding: 12px !important;
    }

    .canvas-container{
        max-width: 100% !important;
        overflow: auto !important;
        -webkit-overflow-scrolling: touch;
    }

    /* Sidebar buttons: 2-column grid */
    .sidebar-controls{
        display: grid !important;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        align-items: stretch;
    }
    .sidebar-controls .btn,
    .sidebar-controls button{
        width: 100%;
        justify-content: center;
    }

    /* Hide sub-headings to save space */
    .sidebar-subtitle,
    .subheading,
    .section-subtitle{
        display: none !important;
    }

    /* Notes panel should behave like normal flow (no overlay) */
    .user-notes-panel{
        max-width: 100% !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }
}

.sidebar{
                width: 280px !important;
                height: 100vh !important;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            .main-content, .content, .main{
                height: 100vh;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Sidebar buttons as 2-column grid to avoid long scrolling */
            .sidebar-controls{
                display: grid !important;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 10px;
                align-items: stretch;
            }
            .sidebar-controls .btn,
            .sidebar-controls button{
                width: 100%;
                justify-content: center;
            }

            /* Hide sub-headings to save space */
            .sidebar-subtitle,
            .subheading,
            .section-subtitle{
                display: none !important;
            }
        }

    </style>
<style id="rrz-desktop-scroll-fix">
/* === RRZ Desktop/Laptop Scroll-Pan Fix (UI only) ===
   Goal: enable vertical scrolling on PC/Laptop where previous rules forced overflow:hidden.
   Does NOT touch any JS logic, functions, or calculations.
*/
@media (min-width: 1025px){
  html, body{
    height: auto !important;
    min-height: 100% !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    overscroll-behavior: auto !important;
  }
  /* Let the page grow so the browser scrollbar appears */
  .app-container,
  .analysis-container,
  .main-content,
  .content-area,
  .analysis-panel,
  .report-section,
  .notes-section{
    height: auto !important;
    min-height: 0 !important;
    overflow: visible !important;
  }
  /* If a workflow uses a full-height flex shell, allow it to expand */
  .analysis-container{ align-items: stretch !important; }
}

/* Large tablets / small laptops */
@media (min-width: 768px) and (max-width: 1024px){
  html, body{
    overflow-y: auto !important;
    overflow-x: hidden !important;
  }
}
</style>
</head>
<body>

<div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2><i class="fas fa-ruler-combined"></i> Occlusal Analysis</h2>
                <div class="sidebar-subtitle">Measure Occlusal Cant & Midline Shift</div>
            </div>
            
            <div class="points-section">
                <div class="section-title">
                    <span>Measurement Points</span>
                    <span id="points-count">0/8</span>
                </div>
                <select class="points-wheel" id="points-list" size="12" aria-label="Points List"></select>
                <div class="undo-wrap">
                    <button class="btn btn-secondary" id="undo-point-btn" type="button">
                        Undo Point Placement
                    </button>
                </div>
            </div>

            <div class="sidebar-controls">
                <button class="btn btn-primary" id="start-analysis-btn">
                    <i class="fas fa-calculator"></i> Analyze Face
                </button>
                <button class="btn btn-secondary" id="calibration-btn">
                    <i class="fas fa-ruler"></i> Calibration
                </button>
                <button class="btn btn-reference" id="reference-btn">
                    <i class="fas fa-question-circle"></i> Reference Guide
                </button>
                <button class="btn btn-export" id="export-btn">
                    <i class="fas fa-download"></i> Export Analysis
                </button>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="main-header">
                <h1><i class="fas fa-tooth"></i> Occlusal Analysis Pro</h1>
                <div class="main-header-subtitle">Precise measurement of Occlusal Cant and Midline Shift</div>
            </div>
            
            <div class="analysis-container">
                <div class="image-section">
                    <div id="auto-load-overlay" class="auto-load-overlay" style="display:none;">
                        <div class="auto-load-card">
                            <div class="spinner"></div>
                            <div style="font-weight:800; margin-top:10px;">Loading imageâ€¦</div>
                            <div style="opacity:.75; font-size:13px; margin-top:6px;">Preparing workflow</div>
                        </div>
                    </div>

                    <!-- Upload Area -->
                    <div class="upload-area active" id="upload-area">
                        <div class="upload-card">
                            <div class="upload-icon">
                                <i class="fas fa-cloud-upload-alt"></i>
                            </div>
                            <h2 class="upload-title">Upload Frontal Photo</h2>
                            <p class="upload-subtitle">Upload a clear frontal photo with eyes open and teeth visible. Ensure face is relaxed with natural head position.</p>
                            
                            <button class="upload-btn" id="main-upload-btn">
                                <i class="fas fa-camera"></i> Select Image
                            </button>
                            
                            <div class="upload-note">
                                <i class="fas fa-info-circle"></i>
                                <span>Supported formats: JPG, PNG, WebP. Max file size: 5MB</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Canvas Area -->
                    <div class="canvas-container" id="canvas-container">
                        <canvas id="face-canvas" width="800" height="600"></canvas>
                    </div>
                    
                    <!-- Image Controls -->
                    <div class="image-controls" id="image-controls">
                        <button class="btn btn-upload" onclick="document.getElementById('image-upload').click()">
                            <i class="fas fa-sync-alt"></i> Change Image
                        </button>
                        <button class="btn btn-reset" onclick="resetAll()">
                            <i class="fas fa-redo"></i> Reset All Points
                        </button>
                        <div style="margin-left: auto; color: #7f8c8d; font-size: 14px;">
                            <i class="fas fa-mouse-pointer"></i> Click to place, drag to adjust points
                        </div>
                    </div>
                </div>
                
                <div class="analysis-section">
                    <div class="analysis-tabs">
                        <div class="tab active" data-tab="cant">Occlusal Cant</div>
                        <div class="tab" data-tab="midline">Midline Shift</div>
                        <div class="tab" data-tab="summary">Summary</div>
                    </div>
                    
                    <div id="cant-tab" class="tab-content active">
                        <h3 style="margin-top: 0; color: #2c3e50;">Occlusal Cant Analysis</h3>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Interpupillary Line (Horizontal)</div>
                                <div class="metric-value" id="interpupillary-status">--</div>
                            </div>
                            <div class="metric-description">
                                Line connecting right and left pupil centers. Should be perfectly horizontal.
                            </div>
                            <div class="progress-container">
                                <div class="progress-label">
                                    <span>Horizontal Alignment</span>
                                    <span id="horizontal-align">--</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="horizontal-progress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Occlusal Cant Angle</div>
                                <div class="metric-value" id="cant-angle-status">--</div>
                            </div>
                            <div class="metric-description">
                                Angle between Occlusal Plane and Interpupillary Line
                            </div>
                            <div class="progress-container">
                                <div class="progress-label">
                                    <span>Cant Angle</span>
                                    <span id="cant-angle-value">--</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="cant-angle-progress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        
                        <table class="results-table" id="cant-table">
                            <thead>
                                <tr>
                                    <th>Measurement</th>
                                    <th>Value</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Cant measurements will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div id="midline-tab" class="tab-content">
                        <h3 style="margin-top: 0; color: #2c3e50;">Midline Shift Analysis</h3>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Facial Midline (Nasion-Menton)</div>
                                <div class="metric-value" id="facial-midline-status">--</div>
                            </div>
                            <div class="metric-description">
                                Vertical line from Nasion to Menton. Should be perpendicular to Interpupillary Line.
                            </div>
                            <div class="progress-container">
                                <div class="progress-label">
                                    <span>Perpendicularity to Eye Line</span>
                                    <span id="perpendicular-status">--</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="perpendicular-progress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        
                        <table class="results-table" id="midline-table">
                            <thead>
                                <tr>
                                    <th>Measurement</th>
                                    <th>Value</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Midline measurements will be populated here -->
                            </tbody>
                        </table>
                        
                        <div class="metric-card" style="margin-top: 20px;">
                            <div class="metric-header">
                                <div class="metric-title">Inter-dental Discrepancy</div>
                                <div class="metric-value" id="interdental-status">--</div>
                            </div>
                            <div class="metric-description" id="interdental-info">
                                Distance between Upper and Lower incisor midpoints
                            </div>
                        </div>
                    </div>
                    
                    <div id="summary-tab" class="tab-content">
                        <h3 style="margin-top: 0; color: #2c3e50;">Analysis Summary</h3>
                        
                        <div class="metric-card good">
                            <div class="metric-header">
                                <div class="metric-title">Overall Assessment</div>
                                <div class="metric-value" id="overall-assessment">Pending</div>
                            </div>
                            <div class="metric-description" id="overall-description">
                                Complete all measurements for assessment
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Occlusal Cant</div>
                                <div class="metric-value" id="summary-cant">--</div>
                            </div>
                            <div class="metric-description">
                                <span id="cant-clinical">Measure to view clinical significance</span>
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Maxillary Shift</div>
                                <div class="metric-value" id="summary-maxillary">--</div>
                            </div>
                            <div class="metric-description">
                                Upper incisor deviation from facial midline
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Mandibular Shift</div>
                                <div class="metric-value" id="summary-mandibular">--</div>
                            </div>
                            <div class="metric-description">
                                Lower incisor deviation from facial midline
                            </div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-header">
                                <div class="metric-title">Calibration Status</div>
                                <div class="metric-value" id="calibration-status">Pixels</div>
                            </div>
                            <div class="metric-description" id="calibration-info">
                                Currently using pixel measurements. Click "Calibration" to set millimeter conversion.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot" id="image-status-dot"></div>
                    <span id="image-status">No image loaded</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="points-status-dot"></div>
                    <span id="points-status">0 points placed</span>
                </div>
                <div class="status-item">
                    <div class="points-progress">
                        <div class="points-progress-fill" id="points-progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Calibration Modal -->
    <div id="calibration-modal" class="modal">
        <div class="modal-content calib-unified">
            <div class="modal-header">
                <h2><i class="fas fa-ruler"></i> Calibration Settings</h2>
                <span class="close-modal">&times;</span>
            </div>
            
            <p>Choose calibration method to convert pixels to real-world measurements.</p>
            
            <div class="calibration-options">
                <div class="calibration-option" id="manual-calibration">
                    <div class="calibration-icon">
                        <svg viewBox="0 0 64 64" aria-hidden="true" focusable="false" style="width:44px;height:44px;display:inline-block;" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
  <rect x="10" y="14" width="44" height="36" rx="6"></rect>
  <path d="M18 22v8M24 22v6M30 22v8M36 22v6M42 22v8M48 22v6"></path>
  <path d="M18 42v6M24 42v4M30 42v6M36 42v4M42 42v6M48 42v4"></path>
</svg>
                    </div>
                    <h3>Manual (mm)</h3>
                    <p>Enter a known measurement in millimeters for accurate conversion</p>
                </div>
                
                <div class="calibration-option" id="pixel-calibration">
                    <div class="calibration-icon">
                        <svg viewBox="0 0 64 64" aria-hidden="true" focusable="false" style="width:44px;height:44px;display:inline-block;" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
  <rect x="12" y="12" width="40" height="40" rx="6"></rect>
  <path d="M24 12v40M40 12v40M12 24h40M12 40h40"></path>
  <path d="M18 58h28" stroke-width="0"></path>
</svg>
                    </div>
                    <h3>Continue with Pixels</h3>
                    <p>Use pixel measurements without conversion to real units</p>
                </div>
            </div>
            
            <div class="calibration-input" id="manual-input">
                <label for="known-distance">Enter known distance in mm (e.g., distance between pupils):</label>
                <input type="number" id="known-distance" step="0.1" min="1" placeholder="e.g., 65.0">
                <p style="margin-top: 10px; font-size: 13px; color: #7f8c8d;">
                    <i class="fas fa-info-circle"></i> Measure a known distance on the face in mm and enter it above
                </p>
            </div>
            
            <div style="text-align: right; margin-top: 25px;">
                <button class="btn btn-secondary" id="cancel-calibration">Cancel</button>
                <button class="btn btn-primary" id="apply-calibration">Apply Calibration</button>
            </div>
        </div>
    </div>
    
    <!-- Reference Modal -->
    <div id="reference-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-map-marker-alt"></i> Occlusal Analysis Reference Guide</h2>
                <span class="close-modal">&times;</span>
            </div>
            
            <p>Place these 8 landmarks accurately for precise occlusal analysis. Click and drag to adjust point positions.</p>
            
            <div class="reference-grid">
                <div class="reference-image-container">
                    <img src="referance image3.png" alt="Occlusal landmarks reference" class="reference-image"
                         onerror="this.onerror=null; this.src='data:image/svg+xml;charset=UTF-8,<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 800 600&quot;><rect width=&quot;800&quot; height=&quot;600&quot; fill=&quot;%23f0f0f0&quot;/><text x=&quot;400&quot; y=&quot;300&quot; font-family=&quot;Arial&quot; font-size=&quot;24&quot; text-anchor=&quot;middle&quot; fill=&quot;%23333&quot;>Occlusal Reference</text></svg>';">
                </div>

                <div class="reference-list">
                    <ol>
                        <li><strong>Right Pupil Center:</strong> Center of right pupil</li>
                        <li><strong>Left Pupil Center:</strong> Center of left pupil</li>
                        <li><strong>Nasion (N):</strong> Bridge of nose between eyes (soft tissue)</li>
                        <li><strong>Menton (Me):</strong> Lowest point of chin (soft tissue)</li>
                        <li><strong>Right Canine Tip:</strong> Tip of right maxillary canine</li>
                        <li><strong>Left Canine Tip:</strong> Tip of left maxillary canine</li>
                        <li><strong>Upper Incisor Midpoint:</strong> Contact between upper central incisors</li>
                        <li><strong>Lower Incisor Midpoint:</strong> Contact between lower central incisors</li>
</ol>
                </div>
            </div>
        </div>
    </div>
    
    <input type="file" id="image-upload" accept="image/*" style="display: none;">

    <script>
        // Application state
        let state = {
            
            analysisActive: false,imageLoaded: false,
            points: [],
            placementHistory: [],
            currentPointIndex: null,
            image: null,
            ctx: null,
            canvas: null,
            isDragging: false,
            dragPointIndex: null,
            calibration: {
                method: 'pixels',
                pixelsPerMM: 1,
                knownDistanceMM: null
            },
            measurements: {},
            angles: {},
            pointLabels: [
                "Right Pupil Center",
                "Left Pupil Center",
                "Nasion (N)",
                "Menton (Me)",
                "Right Canine Tip",
                "Left Canine Tip",
                "Upper Incisor Midpoint",
                "Lower Incisor Midpoint"
            ],
            measurementLabels: {
                'interpupillary': 'Interpupillary Distance',
                'facialHeight': 'Nasion-Menton Height',
                'cantAngle': 'Occlusal Cant Angle',
                'maxillaryShift': 'Maxillary Midline Shift',
                'mandibularShift': 'Mandibular Midline Shift',
                'interdentalShift': 'Inter-dental Discrepancy'
            }
        };

        // Canvas globals
        let canvas = null;
        let ctx = null;
        let measurementLabels = [];

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('face-canvas');
            ctx = canvas.getContext('2d');
            state.canvas = canvas;
            state.ctx = ctx;
            
            // Set up event listeners
            document.getElementById('image-upload').addEventListener('change', handleImageUpload);
            
            // Canvas mouse events
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseUp);
            
            // Set up main upload button
            document.getElementById('main-upload-btn').addEventListener('click', function() {
                document.getElementById('image-upload').click();
            });
            
            // Set up calibration modal
            const calibrationBtn = document.getElementById('calibration-btn');
            const calibrationModal = document.getElementById('calibration-modal');
            const closeCalibration = document.querySelector('#calibration-modal .close-modal');
            const cancelCalibration = document.getElementById('cancel-calibration');
            const applyCalibration = document.getElementById('apply-calibration');
            const manualCalibration = document.getElementById('manual-calibration');
            const pixelCalibration = document.getElementById('pixel-calibration');
            
            calibrationBtn.addEventListener('click', function() {
                if (!state.imageLoaded) {
                    alert("Please upload an image first");
                    return;
                }
                calibrationModal.style.display = 'block';
            });
            
            closeCalibration.addEventListener('click', function() {
                calibrationModal.style.display = 'none';
            });
            
            cancelCalibration.addEventListener('click', function() {
                calibrationModal.style.display = 'none';
            });
            
            manualCalibration.addEventListener('click', function() {
                manualCalibration.classList.add('selected');
                pixelCalibration.classList.remove('selected');
                document.getElementById('manual-input').classList.add('active');
            });
            
            pixelCalibration.addEventListener('click', function() {
                pixelCalibration.classList.add('selected');
                manualCalibration.classList.remove('selected');
                document.getElementById('manual-input').classList.remove('active');
            });
            
            applyCalibration.addEventListener('click', function() {
                if (manualCalibration.classList.contains('selected')) {
                    const knownDistance = parseFloat(document.getElementById('known-distance').value);
                    if (!knownDistance || knownDistance <= 0) {
                        alert("Please enter a valid distance in mm");
                        return;
                    }
                    
                    // Calculate pixels per mm based on interpupillary distance
                    if (state.points[0] && state.points[1]) {
                        const interpupillaryPixels = calculateDistance(state.points[0], state.points[1]);
                        state.calibration.pixelsPerMM = interpupillaryPixels / knownDistance;
                        state.calibration.method = 'mm';
                        state.calibration.knownDistanceMM = knownDistance;
                        
                        document.getElementById('calibration-status').textContent = 'Millimeters';
                        document.getElementById('calibration-info').textContent = 
                            `Calibrated: ${state.calibration.pixelsPerMM.toFixed(2)} pixels/mm (based on ${knownDistance}mm interpupillary distance)`;
                    } else {
                        alert("Please place pupil points first for accurate calibration");
                        return;
                    }
                } else {
                    state.calibration.method = 'pixels';
                    state.calibration.pixelsPerMM = 1;
                    document.getElementById('calibration-status').textContent = 'Pixels';
                    document.getElementById('calibration-info').textContent = 
                        'Using pixel measurements without conversion';
                }
                
                calibrationModal.style.display = 'none';
                
                // Calibration change invalidates analysis; press Analyze Face to recalculate
                invalidateAnalysisState();
            });
            
            // Set up reference modal
            const referenceBtn = document.getElementById('reference-btn');
            const closeModal = document.querySelector('#reference-modal .close-modal');
            const modal = document.getElementById('reference-modal');
            
            referenceBtn.addEventListener('click', function() {
                modal.style.display = 'block';
            });
            
            closeModal.addEventListener('click', function() {
                modal.style.display = 'none';
            });
            
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
                if (event.target === calibrationModal) {
                    calibrationModal.style.display = 'none';
                }
            });
            
            // Set up tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });
            
            // Set up analysis button
            document.getElementById('start-analysis-btn').addEventListener('click', function() {
                if (!state.imageLoaded) {
                    alert("Please upload an image first");
                    return;
                }
                
                if (!allPointsPlaced()) {
                    alert(`Please place all ${state.pointLabels.length} points before Analyze Face`);
                    return;
                }
                
                performAnalysis();
            });
            
            // Set up export button
            document.getElementById('export-btn').addEventListener('click', function() {
                exportAnalysis();
            });
            
            // Initialize points list
            initializePointsList();

            // Undo point placement
            const undoBtn = document.getElementById('undo-point-btn');
            if (undoBtn) {
                undoBtn.addEventListener('click', undoPointPlacement);
            }

            
            // Update status
            updateStatus();
            updateUndoButton();
        
            // Auto-load image if coming from photo.html
            rrzAutoLoadFromPhoto();
            // Safety: never leave overlay stuck (e.g. IndexedDB blocked on some browsers)
            const RRZ_AUTOLOAD_TIMEOUT_MS = 2500;
            setTimeout(() => {
                try{
                    const ov = document.getElementById('auto-load-overlay');
                    if (!ov) return;
                    if (ov.style.display !== 'none' && !state.imageLoaded){
                        ov.style.display = 'none';
                        document.documentElement.classList.remove('from-photo');
                        const ua = document.getElementById('upload-area');
                        if (ua) ua.classList.add('active');
                    }
                }catch(e){}
            }, RRZ_AUTOLOAD_TIMEOUT_MS);

        });

        // Initialize points list in sidebar
        function initializePointsList() {
            const pointsList = document.getElementById('points-list');
            if (!pointsList) return;

            pointsList.innerHTML = '';

            // Scroll wheel selection (native <select>)
            pointsList.onchange = function() {
                const idx = parseInt(this.value, 10);
                if (!Number.isNaN(idx)) selectPoint(idx);
            };

            state.pointLabels.forEach((label, index) => {
                const [name, description] = label.split(' (');
                const desc = description ? description.replace(')', '') : '';

                const baseText = `${index + 1}. ${name}${desc ? ' ' + desc : ''}`;

                const opt = document.createElement('option');
                opt.value = String(index);
                opt.id = `point-option-${index}`;
                opt.dataset.baseText = baseText;
                opt.textContent = baseText;

                pointsList.appendChild(opt);
            });
        }

        // Select a point from the sidebar
        function selectPoint(index) {
            if (!state.imageLoaded) {
                alert("Please upload an image first");
                return;
            }

            // Update UI (scroll wheel)
            const pointsList = document.getElementById('points-list');
            if (pointsList) {
                pointsList.value = String(index);
            }

            // Update state
            state.currentPointIndex = index;

            // Change cursor
            state.canvas.style.cursor = 'crosshair';
        }

        // Handle image upload
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (5MB limit)
            if (file.size > 5 * 1024 * 1024) {
                alert("File size exceeds 5MB limit. Please choose a smaller image.");
                return;
            }
            
            // Check file type
            const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
            if (!validTypes.includes(file.type)) {
                alert("Please upload a valid image file (JPG, PNG, or WebP).");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Calculate dimensions to fit canvas while maintaining aspect ratio
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxWidth) {
                        height = (maxWidth / width) * height;
                        width = maxWidth;
                    }
                    
                    if (height > maxHeight) {
                        width = (maxHeight / height) * width;
                        height = maxHeight;
                    }
                    
                    state.canvas.width = width;
                    state.canvas.height = height;
                    
                    // Draw image
                    state.ctx.drawImage(img, 0, 0, width, height);
                    state.image = img;
                    state.imageLoaded = true;
                    
                    // Hide upload area and show canvas
                    document.getElementById('upload-area').classList.remove('active');
                    document.getElementById('canvas-container').classList.add('active');
                    document.getElementById('image-controls').classList.add('active');
                    
                    // Reset points
                    state.points = [];
                    state.placementHistory = [];
                    updateUndoButton();
            state.placementHistory = [];
            updateUndoButton();
                    state.currentPointIndex = null;
                    measurementLabels = [];
                    
                    // Reset UI
                    resetPointListUI();
                    resetAnalysis();
                    
                    // Update status
                    updateStatus();
                    
                    // Auto-select first point
                    setTimeout(() => selectPoint(0), 500);
                

                    // Show calibration modal (same behavior as workflow.html)
                    setTimeout(() => {
                        const m = document.getElementById('calibration-modal');
                        if (m) m.style.display = 'block';
                    }, 800);
};
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert("Error reading file. Please try again.");
            };
            reader.readAsDataURL(file);
        }

        /* ---------- Auto-load from photo.html (IndexedDB) ---------- */
        const RRZ_DB_NAME = "rrz_clinical_photos_db";
        const RRZ_DB_STORE = "images";
        const RRZ_DB_VER = 1;

        function rrzOpenDB(){
            return new Promise((resolve, reject)=>{
                const req = indexedDB.open(RRZ_DB_NAME, RRZ_DB_VER);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains(RRZ_DB_STORE)){
                        db.createObjectStore(RRZ_DB_STORE, { keyPath:"id" });
                    }
                };
                req.onsuccess = ()=> resolve(req.result);
                req.onerror = ()=> reject(req.error);
            });
        }

        async function rrzGetImageRecord(id){
            const db = await rrzOpenDB();
            return new Promise((resolve, reject)=>{
                const tx = db.transaction(RRZ_DB_STORE, "readonly");
                const req = tx.objectStore(RRZ_DB_STORE).get(String(id||""));
                req.onsuccess = ()=> { const r = req.result; db.close(); resolve(r || null); };
                req.onerror = ()=> { db.close(); reject(req.error); };
            });
        }

        function rrzGetSlotId(){
            try{
                const qs = new URLSearchParams(location.search);
                return qs.get("slot") || sessionStorage.getItem("rrz_workflow_slot") || "";
            }catch(e){ return ""; }
        }

        function rrzLoadImageFromBlob(blob){
            return new Promise((resolve, reject)=>{
                try{
                    const reader = new FileReader();
                    reader.onload = function(e){
                        const img = new Image();
                        img.onload = function(){
                            const maxWidth = 800;
                            const maxHeight = 600;
                            let width = img.width;
                            let height = img.height;
                            if (width > maxWidth) { height = (maxWidth / width) * height; width = maxWidth; }
                            if (height > maxHeight){ width = (maxHeight / height) * width; height = maxHeight; }

                            canvas.width = width;
                            canvas.height = height;
                            ctx.clearRect(0,0,width,height);
                            ctx.drawImage(img, 0, 0, width, height);

                            state.image = img;
                            state.imageLoaded = true;

                            const ua = document.getElementById('upload-area');
                            if (ua) ua.classList.remove('active');
                            const cc = document.getElementById('canvas-container');
                            if (cc) cc.classList.add('active');
                            const ic = document.getElementById('image-controls');
                            if (ic) ic.classList.add('active');

                            state.points = [];
                            state.placementHistory = [];
                            updateUndoButton();
                            state.currentPointIndex = null;
                            measurementLabels = [];
                            resetPointListUI();
                            resetAnalysis();

                            if (typeof updateStatus === "function") updateStatus();

                            

                            // Auto-select first point and open Calibration Settings (same as workflow.html)
                            setTimeout(() => { 
                                try{ if (typeof selectPoint === "function") selectPoint(0); }catch(e){} 
                            }, 500);
                            setTimeout(() => { 
                                try{ const m = document.getElementById('calibration-modal'); if (m) m.style.display = 'block'; }catch(e){} 
                            }, 800);
resolve(true);
                        };
                        img.onerror = ()=> reject(new Error("Image decode failed"));
                        img.src = e.target.result;
                    };
                    reader.onerror = ()=> reject(reader.error || new Error("File read failed"));
                    reader.readAsDataURL(blob);
                }catch(err){ reject(err); }
            });
        }

        async function rrzAutoLoadFromPhoto(){
            let qs;
            try{ qs = new URLSearchParams(location.search); }catch(e){ qs = null; }
            const from = qs ? (qs.get("from")||"") : "";
            const slot = rrzGetSlotId();
            if (!slot) { 
                const ov = document.getElementById('auto-load-overlay');
                if (ov) ov.style.display = 'none';
                document.documentElement.classList.remove('from-photo');
                return;
            }

            if (from === "photo") document.documentElement.classList.add('from-photo');

            try{
                const rec = await rrzGetImageRecord(slot);
                let blob = (rec && rec.blob) ? rec.blob : null;

                // Fallback: try sessionStorage dataURL set by photo.html
                if (!blob){
                    try{
                        const keys = [
                            `rrz_${slot}_image_dataurl`,
                            `rrz_${slot}_image`,
                            'rrz_uploaded_image',
                            'uploadedImageDataUrl',
                            'selectedImageDataUrl'
                        ];
                        let dataUrl = null;
                        for(const k of keys){
                            const v = (sessionStorage.getItem(k) || '').trim();
                            if (v && v.startsWith('data:image')) { dataUrl = v; break; }
                        }
                        if (dataUrl){
                            blob = await (await fetch(dataUrl)).blob();
                        }
                    }catch(e){}
                }

                if (!blob){
                    document.documentElement.classList.remove('from-photo');
                    const ov = document.getElementById('auto-load-overlay');
                    if (ov) ov.style.display = 'none';
                    const ua = document.getElementById('upload-area');
                    if (ua) ua.classList.add('active');
                    return;
                }

                await rrzLoadImageFromBlob(blob);

                const ov = document.getElementById('auto-load-overlay');
                if (ov) ov.style.display = 'none';
            }catch(err){
                document.documentElement.classList.remove('from-photo');
                const ov = document.getElementById('auto-load-overlay');
                if (ov) ov.style.display = 'none';
                const ua = document.getElementById('upload-area');
                if (ua) ua.classList.add('active');
                console.warn(err);
            }
        }

        // Handle canvas mouse down


// Convert pointer coordinates from CSS pixels to canvas pixels (handles CSS scaling).
function getCanvasPointerPos(evt) {
    const rect = state.canvas.getBoundingClientRect();
    const e = (evt && evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const scaleX = state.canvas.width / rect.width;
    const scaleY = state.canvas.height / rect.height;
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

        function handleCanvasMouseDown(event) {
            if (!state.imageLoaded) return;
            
            const { x, y } = getCanvasPointerPos(event);
            
            // Check if clicking on an existing point to drag
            for (let i = 0; i < state.points.length; i++) {
                if (state.points[i]) {
                    const point = state.points[i];
                    const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                    
                    if (distance < 7) {
                        state.isDragging = true;
                        state.dragPointIndex = i;
                        state.canvas.style.cursor = 'grabbing';
                        // Any point edit invalidates prior analysis; user must re-run Analyze Face
                        invalidateAnalysisState();
                        
                        // Select this point in sidebar
                        selectPoint(i);
                        return;
                    }
                }
            }
            
            // If not dragging and a point is selected, place the point
            if (state.currentPointIndex !== null) {
                const wasEmpty = !state.points[state.currentPointIndex];
                state.points[state.currentPointIndex] = {x, y, label: state.pointLabels[state.currentPointIndex]};
                // Any point edit invalidates prior analysis; user must re-run Analyze Face
                invalidateAnalysisState();
                if (wasEmpty) {
                    state.placementHistory.push(state.currentPointIndex);
                    updateUndoButton();
                }
                
                // Draw the point
                drawAllPoints();
                
                // Update UI
                updatePointStatus(state.currentPointIndex, true);
                
                // Move to next point automatically if not all placed
                const placedCount = state.points.filter(p => p).length;
                if (placedCount < state.pointLabels.length) {
                    let nextIndex = (state.currentPointIndex + 1) % state.pointLabels.length;
                    while (state.points[nextIndex] && nextIndex !== state.currentPointIndex) {
                        nextIndex = (nextIndex + 1) % state.pointLabels.length;
                    }
                    selectPoint(nextIndex);
                } else {
                    state.currentPointIndex = null;
                    state.canvas.style.cursor = 'default';
                }
                
                // Update status (analysis runs only after all points are placed and user presses Analyze Face)
                updateStatus();
            }
        }

        // Handle canvas mouse move
        function handleCanvasMouseMove(event) {
            if (!state.imageLoaded || !state.isDragging || state.dragPointIndex === null) return;
            
            const { x, y } = getCanvasPointerPos(event);
            
            // Update point position
            state.points[state.dragPointIndex] = {
                ...state.points[state.dragPointIndex],
                x, y
            };
            
            // Redraw everything
            drawAllPoints();
            
            // Analysis is run only when the user presses Analyze Face (after all points are placed)
            
        }

        // Handle canvas mouse up
        function handleCanvasMouseUp() {
            if (state.isDragging) {
                state.isDragging = false;
                state.dragPointIndex = null;
                state.canvas.style.cursor = state.currentPointIndex !== null ? 'crosshair' : 'default';
            }
        }

        // Draw all points and measurement lines
        function drawAllPoints() {
            // Clear canvas
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            
            // Redraw image
            if (state.image) {
                state.ctx.drawImage(state.image, 0, 0, state.canvas.width, state.canvas.height);
            }
            
            // Clear existing measurement labels
            measurementLabels.forEach(label => {
                if (label.element && label.element.parentNode) {
                    label.element.parentNode.removeChild(label.element);
                }
            });
            measurementLabels = [];
            
            // Draw all points
            state.points.forEach((point, index) => {
                if (point) {
                    drawPoint(point.x, point.y, index);
                }
            });
            
            // Draw measurement lines only after analysis is started
            if (state.analysisActive && allPointsPlaced()) {
                drawMeasurementLines();
            }
}

        // Draw a single point
        function drawPoint(x, y, index) {
            // Draw point circle
            state.ctx.beginPath();
            state.ctx.arc(x, y, 4, 0, Math.PI * 2);
            state.ctx.fillStyle = '#e74c3c';
            state.ctx.fill();
            state.ctx.strokeStyle = 'white';
            state.ctx.lineWidth = 1.5;
            state.ctx.stroke();
            
            // Draw number inside
            state.ctx.font = 'bold 10px Arial';
            state.ctx.fillStyle = 'white';
            state.ctx.textAlign = 'center';
            state.ctx.textBaseline = 'middle';
            state.ctx.fillText(index + 1, x, y);
            
            // Draw drag handle indicator
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.strokeStyle = 'rgba(52, 152, 219, 0.3)';
            state.ctx.lineWidth = 1;
            state.ctx.stroke();

            // Draw full point name next to the point (English name)
            const fullLabel = (state.pointLabels[index] || '').split(' ')[0] || '';
            if (fullLabel) {
                const tx = x + 10;
                const ty = y - 10;
                state.ctx.font = '600 11px Arial';
                state.ctx.textAlign = 'left';
                state.ctx.textBaseline = 'middle';
                state.ctx.lineWidth = 1.5;
                state.ctx.strokeStyle = 'rgba(0,0,0,0.65)';
                state.ctx.strokeText(fullLabel, tx, ty);
                state.ctx.fillStyle = 'white';
                state.ctx.fillText(fullLabel, tx, ty);
            }
        }

        // Draw measurement lines and labels
        function drawMeasurementLines() {
            const points = state.points;
            if (!points[0] || !points[1] || !points[2] || !points[3]) return;
            
            // 1. Draw Interpupillary Line (Horizontal Reference)
            if (points[0] && points[1]) {
                drawLineWithLabel(points[0], points[1], '#3498db', 'Interpupillary Line');
            }
            
            // 2. Draw Nasion-Menton Line (Vertical Midline)
            if (points[2] && points[3]) {
                drawLineWithLabel(points[2], points[3], '#2ecc71', 'Facial Midline');
            }
            
            // 3. Draw Occlusal Plane (Canine to Canine)
            if (points[4] && points[5]) {
                drawLineWithLabel(points[4], points[5], '#9b59b6', 'Occlusal Plane');
            }
            
            // 4. Draw perpendicular lines for shift measurements
            if (points[2] && points[3] && points[6]) {
                // Upper incisor to facial midline projection
                const projectionY = points[6].y;
                const projectionX = points[2].x; // Same x as nasion (vertical line)
                drawDashedLine({x: points[6].x, y: projectionY}, {x: projectionX, y: projectionY}, '#f39c12', 'Upper Shift');
            }
            
            if (points[2] && points[3] && points[7]) {
                // Lower incisor to facial midline projection
                const projectionY = points[7].y;
                const projectionX = points[2].x; // Same x as nasion (vertical line)
                drawDashedLine({x: points[7].x, y: projectionY}, {x: projectionX, y: projectionY}, '#1abc9c', 'Lower Shift');
            }
        }

        // Draw line with measurement label
        function drawLineWithLabel(p1, p2, color, label) {
            // Draw line
            state.ctx.beginPath();
            state.ctx.moveTo(p1.x, p1.y);
            state.ctx.lineTo(p2.x, p2.y);
            state.ctx.strokeStyle = color;
            state.ctx.lineWidth = 1.5;
            state.ctx.stroke();
            
            // Calculate midpoint
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            
            // Calculate distance
            const distance = calculateDistance(p1, p2);
            const displayDistance = formatDistance(distance);
            
            // Create measurement label with transparent background
            const labelElement = document.createElement('div');
            labelElement.className = 'measurement-label';
            labelElement.style.left = (midX + 10) + 'px';
            labelElement.style.top = (midY - 20) + 'px';
            labelElement.innerHTML = `${label}: <span class="value">${displayDistance}</span>`;
            
            document.getElementById('canvas-container').appendChild(labelElement);
            measurementLabels.push({element: labelElement, x: midX, y: midY});
            
            return distance;
        }

        // Draw dashed line
        function drawDashedLine(p1, p2, color, label) {
            // Draw dashed line
            state.ctx.beginPath();
            state.ctx.setLineDash([5, 3]);
            state.ctx.moveTo(p1.x, p1.y);
            state.ctx.lineTo(p2.x, p2.y);
            state.ctx.strokeStyle = color;
            state.ctx.lineWidth = 2;
            state.ctx.stroke();
            state.ctx.setLineDash([]);
            
            // Calculate distance
            const distance = Math.abs(p2.x - p1.x);
            const displayDistance = formatDistance(distance);
            
            // Create measurement label
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            
            const labelElement = document.createElement('div');
            labelElement.className = 'measurement-label';
            labelElement.style.left = (midX - 60) + 'px';
            labelElement.style.top = (midY - 25) + 'px';
            labelElement.innerHTML = `${label}: <span class="value">${displayDistance}</span>`;
            
            document.getElementById('canvas-container').appendChild(labelElement);
            measurementLabels.push({element: labelElement, x: midX, y: midY});
            
            return distance;
        }

        // Update point status in sidebar
        function updatePointStatus(index, placed) {
            const opt = document.getElementById(`point-option-${index}`);
            if (!opt) return;

            const base = opt.dataset.baseText || opt.textContent.replace(/^âœ“\s*/, '');
            opt.dataset.baseText = base;

            opt.textContent = placed ? `âœ“ ${base}` : base;
        }

        // Update status bar
        function updateStatus() {
            const placedCount = state.points.filter(p => p).length;
            const totalPoints = state.pointLabels.length;
            
            document.getElementById('points-count').textContent = `${placedCount}/${totalPoints}`;
            document.getElementById('points-status').textContent = `${placedCount} of ${totalPoints} points placed`;
            
            const progressPercent = (placedCount / totalPoints) * 100;
            document.getElementById('points-progress-fill').style.width = `${progressPercent}%`;
            
            const imageStatusDot = document.getElementById('image-status-dot');
            const pointsStatusDot = document.getElementById('points-status-dot');
            
            if (state.imageLoaded) {
                document.getElementById('image-status').textContent = 'Image loaded';
                imageStatusDot.classList.add('active');
            } else {
                document.getElementById('image-status').textContent = 'No image loaded';
                imageStatusDot.classList.remove('active');
            }
            
            if (placedCount >= 7) {
                pointsStatusDot.classList.add('active');
            } else {
                pointsStatusDot.classList.remove('active');
            }
        }

        // Switch between tabs
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabId}-tab`).classList.add('active');
        }


        // Enable/disable Undo button
        function updateUndoButton() {
            const btn = document.getElementById('undo-point-btn');
            if (!btn) return;
            const canUndo = Array.isArray(state.placementHistory) && state.placementHistory.length > 0;
            btn.disabled = !canUndo;
        }

        // Undo last point placement (removes last placed point and returns selection to it)
        function undoPointPlacement() {
            if (!state.imageLoaded) return;
            if (!Array.isArray(state.placementHistory) || state.placementHistory.length === 0) {
                updateUndoButton();
                return;
            }

            const lastIdx = state.placementHistory.pop();
            if (lastIdx === null || lastIdx === undefined) {
                updateUndoButton();
                return;
            }

            // Remove the point
            state.points[lastIdx] = null;

            // Update UI + redraw
            updatePointStatus(lastIdx, false);
            resetAnalysis(); // keep analysis consistent when points drop below threshold
            drawAllPoints();
            updateStatus();

            // Return to the undone point for immediate re-placement
            try { selectPoint(lastIdx); } catch(e) {}

            updateUndoButton();
        }


        // Reset everything
        function resetAll() {
            if (!state.imageLoaded) return;
            
            // Clear canvas
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.image, 0, 0, state.canvas.width, state.canvas.height);
            
            // Clear measurement labels
            measurementLabels.forEach(label => {
                if (label.element && label.element.parentNode) {
                    label.element.parentNode.removeChild(label.element);
                }
            });
            measurementLabels = [];
            
            // Reset points
            state.points = [];
            state.currentPointIndex = null;
            state.isDragging = false;
            state.dragPointIndex = null;
            state.canvas.style.cursor = 'default';
            
            // Reset measurements
            state.measurements = {};
            state.angles = {};
            
            // Reset UI
            resetPointListUI();
            resetAnalysis();
            updateStatus();
            
            // Auto-select first point
            selectPoint(0);
        }

        // Reset points UI
        function resetPointListUI() {
            for (let i = 0; i < state.pointLabels.length; i++) {
                updatePointStatus(i, false);
            }
        }

        // Reset analysis displays
        function resetAnalysis() {
            state.analysisActive = false;
            document.getElementById('cant-table').innerHTML = `
                <thead>
                    <tr>
                        <th>Measurement</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            
            document.getElementById('midline-table').innerHTML = `
                <thead>
                    <tr>
                        <th>Measurement</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            
            // Reset all metric displays
            const metricIds = [
                'interpupillary-status', 'horizontal-align', 'cant-angle-status', 'cant-angle-value',
                'facial-midline-status', 'perpendicular-status', 'interdental-status',
                'overall-assessment', 'summary-cant', 'summary-maxillary', 'summary-mandibular'
            ];
            
            metricIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = '-';
            });
            
            // Reset progress bars
            document.getElementById('horizontal-progress').style.width = '0%';
            document.getElementById('cant-angle-progress').style.width = '0%';
            document.getElementById('perpendicular-progress').style.width = '0%';
            
            document.getElementById('overall-description').textContent = 'Complete all measurements for assessment';
            document.getElementById('cant-clinical').textContent = 'Measure to view clinical significance';
            if (state.imageLoaded) { try { drawAllPoints(); } catch(e) {} }

        }

        // Calculate distance between two points
        function calculateDistance(p1, p2) {
            return Math.hypot(p2.x - p1.x, p2.y - p1.y);
        }

        // Calculate angle between two lines
        function calculateAngle(p1, p2, p3, p4) {
            const dx1 = p2.x - p1.x;
            const dy1 = p2.y - p1.y;
            const dx2 = p4.x - p3.x;
            const dy2 = p4.y - p3.y;
            
            const angle1 = Math.atan2(dy1, dx1);
            const angle2 = Math.atan2(dy2, dx2);
            
            let angle = Math.abs(angle1 - angle2) * (180 / Math.PI);
            
            // Ensure angle is between 0 and 90 degrees
            if (angle > 90) {
                angle = 180 - angle;
            }
            
            return angle;
        }

        // Format distance based on calibration
        function formatDistance(distanceInPixels) {
            if (state.calibration.method === 'mm' && state.calibration.pixelsPerMM && state.calibration.pixelsPerMM > 0) {
                const distanceInMM = distanceInPixels / state.calibration.pixelsPerMM;
                return distanceInMM.toFixed(1) + ' mm';
            } else {
                return Math.round(distanceInPixels) + ' px';
            }
        }

        // Perform complete analysis
        function performAnalysis() {
            if (!allPointsPlaced()) return;
            
            state.analysisActive = true;

            state.measurements = {};
            state.angles = {};
            
            // 1. Calculate all measurements
            calculateAllMeasurements();
            
            // 2. Calculate all angles
            calculateAllAngles();
            
            // 3. Update UI with results
            updateAnalysisUI();
            
            // 4. Redraw canvas with measurement lines
            drawAllPoints();
        }

        // Calculate all measurements
        function calculateAllMeasurements() {
            const points = state.points;
            
            // 1. Interpupillary distance
            if (points[0] && points[1]) {
                state.measurements.interpupillary = calculateDistance(points[0], points[1]);
            }
            
            // 2. Facial height (Nasion-Menton)
            if (points[2] && points[3]) {
                state.measurements.facialHeight = calculateDistance(points[2], points[3]);
            }
            
            // 3. Maxillary midline shift (horizontal distance from facial midline)
            if (points[2] && points[6]) {
                // Facial midline x-coordinate is nasion x (assuming vertical line)
                state.measurements.maxillaryShift = Math.abs(points[6].x - points[2].x);
            }
            
            // 4. Mandibular midline shift
            if (points[2] && points[7]) {
                state.measurements.mandibularShift = Math.abs(points[7].x - points[2].x);
            }
            
            // 5. Inter-dental discrepancy
            if (points[6] && points[7]) {
                state.measurements.interdentalShift = Math.abs(points[7].x - points[6].x);
            }
        }

        // Calculate all angles
        function calculateAllAngles() {
            const points = state.points;
            
            // 1. Occlusal Cant Angle (angle between occlusal plane and interpupillary line)
            if (points[0] && points[1] && points[4] && points[5]) {
                state.angles.cantAngle = calculateAngle(points[0], points[1], points[4], points[5]);
            }
            
            // 2. Facial midline perpendicularity deviation (0Â° = perfectly perpendicular to eye line)
            if (points[0] && points[1] && points[2] && points[3]) {
                const angleBetween = calculateAngle(points[0], points[1], points[2], points[3]); // 0..90
                state.angles.perpendicularity = Math.abs(90 - angleBetween); // deviation from 90Â°
            }
            
            // 3. Interpupillary line horizontal alignment
            if (points[0] && points[1]) {
                const dx = points[1].x - points[0].x;
                const dy = points[1].y - points[0].y;
                state.angles.horizontalAlignment = Math.abs(Math.atan2(dy, dx) * (180 / Math.PI));
            }
        }

        // Update analysis UI with results
        
        // -----------------------------
        // Analysis gating helpers
        // -----------------------------
        function allPointsPlaced() {
            return state.pointLabels.every((_, i) => !!state.points[i]);
        }

        function clearAnalysisUI() {
            // Clear tables
            const tableIds = ['cant-table', 'midline-table', 'summary-table'];
            tableIds.forEach(id => {
                const t = document.getElementById(id);
                if (!t) return;
                const tb = t.querySelector('tbody');
                if (tb) tb.innerHTML = '';
            });

            // Reset key metrics / statuses
            const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
            const setWidth = (id, val) => { const el = document.getElementById(id); if (el) el.style.width = val; };

            setText('cant-angle-status', '');
            setText('cant-angle-value', '');
            setWidth('cant-angle-progress', '0%');

            setText('perpendicular-status', '');
            setWidth('perpendicular-progress', '0%');

            setText('facial-midline-status', '');

            const interdental = document.getElementById('interdental-status');
            if (interdental) {
                interdental.textContent = '';
                interdental.className = 'metric-value';
            }
            setText('interdental-info', 'Place all points, then press Analyze Face.');

            setText('summary-cant', '');
            setText('summary-maxillary', '');
            setText('summary-mandibular', '');

            setText('cant-clinical', '');
            setText('overall-assessment', 'Not analyzed');
            setText('overall-description', 'Place all points, then press Analyze Face.');
        }

        function invalidateAnalysisState() {
            state.analysisActive = false;
            state.measurements = {};
            state.angles = {};
            clearAnalysisUI();
        }

function updateAnalysisUI() {
            // Update Cant tab
            updateCantTab();
            
            // Update Midline tab
            updateMidlineTab();
            
            // Update Summary tab
            updateSummaryTab();
        }

        // Update Cant tab
        function updateCantTab() {
            const cantTable = document.getElementById('cant-table').querySelector('tbody');
            cantTable.innerHTML = '';
            
            // Interpupillary distance
            if (state.measurements.interpupillary) {
                const row = document.createElement('tr');
                const distance = formatDistance(state.measurements.interpupillary);
                let status = 'Measured';
                let statusClass = '';
                
                if (state.calibration.method === 'mm' && state.measurements.interpupillary / state.calibration.pixelsPerMM > 70) {
                    status = 'Wide';
                    statusClass = 'warning';
                } else if (state.calibration.method === 'mm' && state.measurements.interpupillary / state.calibration.pixelsPerMM < 55) {
                    status = 'Narrow';
                    statusClass = 'warning';
                } else {
                    status = 'Normal';
                    statusClass = 'good';
                }
                
                row.innerHTML = `
                    <td>Interpupillary Distance</td>
                    <td>${distance}</td>
                    <td><span class="${statusClass}">${status}</span></td>
                `;
                cantTable.appendChild(row);
                
                // Update progress bar for horizontal alignment
                if (state.angles.horizontalAlignment) {
                    const alignPercent = Math.max(0, 100 - (state.angles.horizontalAlignment * 10));
                    document.getElementById('horizontal-align').textContent = state.angles.horizontalAlignment.toFixed(1) + 'Â°';
                    document.getElementById('horizontal-progress').style.width = alignPercent + '%';
                    document.getElementById('interpupillary-status').textContent = 
                        state.angles.horizontalAlignment < 2 ? 'Perfectly Horizontal' : 'Slightly Tilted';
                }
            }
            
            // Occlusal Cant Angle
            if (state.angles.cantAngle) {
                const row = document.createElement('tr');
                const angleValue = state.angles.cantAngle.toFixed(1) + 'Â°';
                let status = 'No Cant';
                let statusClass = 'good';
                
                if (state.angles.cantAngle > 4) {
                    status = 'Clinically Significant';
                    statusClass = 'alert';
                } else if (state.angles.cantAngle > 2) {
                    status = 'Moderate Cant';
                    statusClass = 'warning';
                } else {
                    status = 'Minimal Cant';
                    statusClass = 'good';
                }
                
                row.innerHTML = `
                    <td>Occlusal Cant Angle</td>
                    <td>${angleValue}</td>
                    <td><span class="${statusClass}">${status}</span></td>
                `;
                cantTable.appendChild(row);
                
                // Update cant angle display
                document.getElementById('cant-angle-status').textContent = status;
                document.getElementById('cant-angle-value').textContent = angleValue;
                
                const cantPercent = Math.min(100, (state.angles.cantAngle / 10) * 100);
                document.getElementById('cant-angle-progress').style.width = cantPercent + '%';
            }
        }

        // Update Midline tab
        function updateMidlineTab() {
            const midlineTable = document.getElementById('midline-table').querySelector('tbody');
            midlineTable.innerHTML = '';
            
            // Facial height
            if (state.measurements.facialHeight) {
                const row = document.createElement('tr');
                const height = formatDistance(state.measurements.facialHeight);
                row.innerHTML = `
                    <td>Facial Height (Nasion-Menton)</td>
                    <td>${height}</td>
                    <td><span class="good">Measured</span></td>
                `;
                midlineTable.appendChild(row);
                
                // Update perpendicularity
                if (state.angles.perpendicularity) {
                    const perpValue = state.angles.perpendicularity.toFixed(1) + 'Â°';
                    document.getElementById('perpendicular-status').textContent = perpValue;
                    const perpPercent = Math.max(0, 100 - (state.angles.perpendicularity * 10));
                    document.getElementById('perpendicular-progress').style.width = perpPercent + '%';
                    
                    if (state.angles.perpendicularity < 5) {
                        document.getElementById('facial-midline-status').textContent = 'Perpendicular';
                    } else {
                        document.getElementById('facial-midline-status').textContent = 'Deviated';
                    }
                }
            }
            
            // Maxillary midline shift
            if (state.measurements.maxillaryShift) {
                const row = document.createElement('tr');
                const shift = formatDistance(state.measurements.maxillaryShift);
                let status = 'Normal';
                let statusClass = 'good';
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.maxillaryShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        status = 'Clinically Significant';
                        statusClass = 'alert';
                    } else if (shiftMM > 1) {
                        status = 'Moderate';
                        statusClass = 'warning';
                    }
                }
                
                row.innerHTML = `
                    <td>Maxillary Midline Shift</td>
                    <td>${shift}</td>
                    <td><span class="${statusClass}">${status}</span></td>
                `;
                midlineTable.appendChild(row);
            }
            
            // Mandibular midline shift
            if (state.measurements.mandibularShift) {
                const row = document.createElement('tr');
                const shift = formatDistance(state.measurements.mandibularShift);
                let status = 'Normal';
                let statusClass = 'good';
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.mandibularShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        status = 'Clinically Significant';
                        statusClass = 'alert';
                    } else if (shiftMM > 1) {
                        status = 'Moderate';
                        statusClass = 'warning';
                    }
                }
                
                row.innerHTML = `
                    <td>Mandibular Midline Shift</td>
                    <td>${shift}</td>
                    <td><span class="${statusClass}">${status}</span></td>
                `;
                midlineTable.appendChild(row);
            }
            
            // Inter-dental discrepancy
            if (state.measurements.interdentalShift) {
                const discrepancy = formatDistance(state.measurements.interdentalShift);
                document.getElementById('interdental-status').textContent = discrepancy;
                
                let info = '';
                if (state.calibration.method === 'mm') {
                    const discrepancyMM = state.measurements.interdentalShift / state.calibration.pixelsPerMM;
                    if (discrepancyMM > 3) {
                        info = 'Severe discrepancy between upper and lower midlines';
                        document.getElementById('interdental-status').className = 'metric-value alert';
                    } else if (discrepancyMM > 1.5) {
                        info = 'Moderate discrepancy between upper and lower midlines';
                        document.getElementById('interdental-status').className = 'metric-value warning';
                    } else {
                        info = 'Minimal discrepancy between upper and lower midlines';
                        document.getElementById('interdental-status').className = 'metric-value good';
                    }
                } else {
                    info = 'Distance between upper and lower incisor midpoints';
                }
                document.getElementById('interdental-info').textContent = info;
            }
        }

        // Update Summary tab
        function updateSummaryTab() {
            let overallStatus = 'Normal';
            let overallClass = 'good';
            let issues = [];
            
            // Check cant
            if (state.angles.cantAngle) {
                document.getElementById('summary-cant').textContent = state.angles.cantAngle.toFixed(1) + 'Â°';
                
                if (state.angles.cantAngle > 4) {
                    issues.push('Significant occlusal cant (>4Â°)');
                    overallStatus = 'Needs Attention';
                    overallClass = 'alert';
                    document.getElementById('cant-clinical').textContent = 'Clinically visible cant requiring treatment';
                } else if (state.angles.cantAngle > 2) {
                    issues.push('Moderate occlusal cant');
                    if (overallStatus === 'Normal') {
                        overallStatus = 'Borderline';
                        overallClass = 'warning';
                    }
                    document.getElementById('cant-clinical').textContent = 'Moderate cant, may be noticeable';
                } else {
                    document.getElementById('cant-clinical').textContent = 'Minimal cant, within normal limits';
                }
            }
            
            // Check maxillary shift
            if (state.measurements.maxillaryShift) {
                const shift = formatDistance(state.measurements.maxillaryShift);
                document.getElementById('summary-maxillary').textContent = shift;
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.maxillaryShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        issues.push('Significant maxillary midline shift');
                        overallStatus = 'Needs Attention';
                        overallClass = 'alert';
                    } else if (shiftMM > 1 && overallStatus === 'Normal') {
                        issues.push('Moderate maxillary shift');
                        overallStatus = 'Borderline';
                        overallClass = 'warning';
                    }
                }
            }
            
            // Check mandibular shift
            if (state.measurements.mandibularShift) {
                const shift = formatDistance(state.measurements.mandibularShift);
                document.getElementById('summary-mandibular').textContent = shift;
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.mandibularShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        issues.push('Significant mandibular midline shift');
                        overallStatus = 'Needs Attention';
                        overallClass = 'alert';
                    } else if (shiftMM > 1 && overallStatus === 'Normal') {
                        issues.push('Moderate mandibular shift');
                        overallStatus = 'Borderline';
                        overallClass = 'warning';
                    }
                }
            }
            
            // Update overall assessment
            document.getElementById('overall-assessment').textContent = overallStatus;
            document.getElementById('overall-assessment').className = 'metric-value ' + overallClass;
            
            if (issues.length > 0) {
                document.getElementById('overall-description').textContent = 'Issues detected: ' + issues.join(', ');
            } else if (state.angles.cantAngle || state.measurements.maxillaryShift) {
                document.getElementById('overall-description').textContent = 'All measurements within normal limits';
            }
        }

        // Export analysis results
        function exportAnalysis() {
            if (!state.imageLoaded || !state.analysisActive || !allPointsPlaced()) {
                alert("Please place all points and press Analyze Face before exporting.");
                return;
            }
            
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Occlusal Analysis Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        .header { text-align: center;
            text-shadow: 0 2px 6px rgba(0,0,0,0.65); margin-bottom: 30px; }
                        .header h1 { color: #2c3e50; }
                        .image-container { text-align: center;
            text-shadow: 0 2px 6px rgba(0,0,0,0.65); margin: 20px 0; }
                        .image-container img { max-width: 100%; border: 1px solid #ddd; }
                        .results { margin-top: 30px; }
                        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                        th { background: #2c3e50; color: white; padding: 10px; text-align: left; }
                        td { padding: 8px 10px; border-bottom: 1px solid #ddd; }
                        .section { margin: 30px 0; }
                        .section h3 { color: #3498db; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
                        .timestamp { color: #7f8c8d; font-size: 14px; }
                        .good { color: #2ecc71; }
                        .warning { color: #f39c12; }
                        .alert { color: #e74c3c; }
                        @media print {
                            .no-print { display: none; }
                            body { padding: 0; }
                        }
                    

/* === RRZ_SCROLL_PAN_FIX_V1.10 === */
/* UI-only patch: enables scroll-pan on mobile landscape + PC, avoids cropped UI, enlarges landmarks list. */
html, body{
  height: auto !important;
  min-height: 100% !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
body{ -webkit-overflow-scrolling: touch; }

/* Keep portrait rotate overlays effective */
@media (max-width: 900px) and (orientation: portrait){
  html, body{ overflow: hidden !important; }
}

.app-container{
  height: auto !important;
  min-height: 100vh !important;
}

/* Sidebar: make list area large and keep buttons reachable */
.sidebar{
  display: flex !important;
  flex-direction: column !important;
  min-height: 100vh !important;
}
.points-section{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  display: flex !important;
  flex-direction: column !important;
  overflow: auto !important;
}

/* Works for workflows (select list) + (ul list) */
.points-wheel,
.points-list{
  flex: 1 1 auto !important;
  min-height: 300px !important;
  height: auto !important;
  overflow: auto !important;
  -webkit-overflow-scrolling: touch;
}

/* Main layout: remove hard 100vh clipping so Notes/Report can be reached by scroll */
.main-content,
.analysis-container,
.content,
.main{
  height: auto !important;
  min-height: 100vh !important;
  overflow: visible !important;
}

/* Right panels (workflow 8/9 + some others) */
.analysis-panel,
.results-panel,
.right-panel,
.analysis-section,
.user-notes-panel{
  height: auto !important;
  max-height: none !important;
  overflow: visible !important;
  position: static !important;
}

/* Mobile landscape: tighten buttons so they aren't cropped */
@media (max-width: 900px) and (orientation: landscape){
  .sidebar-controls{
    padding: 12px !important;
    gap: 10px !important;
  }
  .sidebar-controls .btn,
  .sidebar-controls button{
    padding: 12px !important;
    font-size: 12px !important;
    border-radius: 10px !important;
  }
  .points-wheel,
  .points-list{
    min-height: 220px !important;
  }
}

/* Desktop/PC: always allow scroll (even if inner sections had fixed heights) */
@media (min-width: 901px){
  .main-content{ overflow: visible !important; }
}
</style>
                </head>
                <body>
                    <div class="header">
                        <h1>Occlusal Analysis Report</h1>
                        <div class="timestamp">Generated: ${new Date().toLocaleString()}</div>
                    </div>
                    
                    <div class="image-container">
                        <h3>Analyzed Frontal View with Measurements</h3>
                        <img src="${state.canvas.toDataURL('image/png')}" alt="Occlusal Analysis">
                    </div>
                    
                    <div class="section">
                        <h3>Occlusal Cant Analysis</h3>
                        <table>
                            <tr>
                                <th>Measurement</th>
                                <th>Value</th>
                                <th>Status</th>
                            </tr>
            `);
            
            // Add cant measurements
            if (state.measurements.interpupillary) {
                const distance = formatDistance(state.measurements.interpupillary);
                printWindow.document.write(`
                    <tr>
                        <td>Interpupillary Distance</td>
                        <td>${distance}</td>
                        <td>${state.angles.horizontalAlignment < 2 ? 'Normal' : 'Tilted'}</td>
                    </tr>
                `);
            }
            
            if (state.angles.cantAngle) {
                const angleValue = state.angles.cantAngle.toFixed(1) + 'Â°';
                let status = 'Minimal Cant';
                let statusClass = 'good';
                
                if (state.angles.cantAngle > 4) {
                    status = 'Clinically Significant';
                    statusClass = 'alert';
                } else if (state.angles.cantAngle > 2) {
                    status = 'Moderate Cant';
                    statusClass = 'warning';
                }
                
                printWindow.document.write(`
                    <tr>
                        <td>Occlusal Cant Angle</td>
                        <td>${angleValue}</td>
                        <td class="${statusClass}">${status}</td>
                    </tr>
                `);
            }
            
            printWindow.document.write(`
                        </table>
                    </div>
                    
                    <div class="section">
                        <h3>Midline Shift Analysis</h3>
                        <table>
                            <tr>
                                <th>Measurement</th>
                                <th>Value</th>
                                <th>Status</th>
                            </tr>
            `);
            
            // Add midline measurements
            if (state.measurements.maxillaryShift) {
                const shift = formatDistance(state.measurements.maxillaryShift);
                let status = 'Normal';
                let statusClass = 'good';
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.maxillaryShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        status = 'Clinically Significant';
                        statusClass = 'alert';
                    } else if (shiftMM > 1) {
                        status = 'Moderate';
                        statusClass = 'warning';
                    }
                }
                
                printWindow.document.write(`
                    <tr>
                        <td>Maxillary Midline Shift</td>
                        <td>${shift}</td>
                        <td class="${statusClass}">${status}</td>
                    </tr>
                `);
            }
            
            if (state.measurements.mandibularShift) {
                const shift = formatDistance(state.measurements.mandibularShift);
                let status = 'Normal';
                let statusClass = 'good';
                
                if (state.calibration.method === 'mm') {
                    const shiftMM = state.measurements.mandibularShift / state.calibration.pixelsPerMM;
                    if (shiftMM > 2) {
                        status = 'Clinically Significant';
                        statusClass = 'alert';
                    } else if (shiftMM > 1) {
                        status = 'Moderate';
                        statusClass = 'warning';
                    }
                }
                
                printWindow.document.write(`
                    <tr>
                        <td>Mandibular Midline Shift</td>
                        <td>${shift}</td>
                        <td class="${statusClass}">${status}</td>
                    </tr>
                `);
            }
            
            if (state.measurements.interdentalShift) {
                const discrepancy = formatDistance(state.measurements.interdentalShift);
                printWindow.document.write(`
                    <tr>
                        <td>Inter-dental Discrepancy</td>
                        <td>${discrepancy}</td>
                        <td>Measured</td>
                    </tr>
                `);
            }
            
            printWindow.document.write(`
                        </table>
                    </div>
                    
                    <div class="section">
                        <h3>Calibration Information</h3>
                        <p>Measurement unit: ${state.calibration.method === 'mm' ? 'Millimeters' : 'Pixels'}</p>
                        ${state.calibration.method === 'mm' ? 
                          `<p>Conversion factor: ${state.calibration.pixelsPerMM.toFixed(2)} pixels per mm</p>` : 
                          ''}
                    </div>
                    
                    <div class="section">
                        <h3>Clinical Recommendations</h3>
                        <p><strong>Occlusal Cant:</strong> ${state.angles.cantAngle > 4 ? 
                          'Consider orthodontic evaluation for cant correction' : 
                          state.angles.cantAngle > 2 ? 
                          'Monitor; may consider minor correction if symptomatic' : 
                          'Within normal limits, no intervention needed'}</p>
                        <p><strong>Midline Shift:</strong> ${state.measurements.maxillaryShift && state.calibration.method === 'mm' && 
                          state.measurements.maxillaryShift / state.calibration.pixelsPerMM > 2 ? 
                          'Significant shift; orthodontic evaluation recommended' : 
                          'Within acceptable limits for most patients'}</p>
                    </div>
                    
                    <div class="no-print" style="margin-top: 30px; text-align: center;
            text-shadow: 0 2px 6px rgba(0,0,0,0.65);">
                        <button onclick="window.print()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Print Report
                        </button>
                    </div>
                    
                    <script>
                        window.onload = function() {
                            // Auto-print option
                            // window.print();
                        };
                    <\/script>
                </body>
                </html>
            `);
            
            printWindow.document.close();
        }
    </script>

<script>
(function(){
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function(){
      navigator.serviceWorker.register('./sw.js').catch(function(){});
    });
  }
})();
</script>
</body>
</html>
